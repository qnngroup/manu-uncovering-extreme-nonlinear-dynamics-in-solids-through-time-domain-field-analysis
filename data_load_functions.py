""" data_load_functions.py
These are a set of convenience functions for loading data from the various simulations analyzed in this project. 
"""

import numpy as np
import physical_constants_atomic as pca
import physical_constants_SI as pcSI
from scipy.signal import tukey


#Function that loads the fields into a library for convenience.
# -- This enables me to load many csv files with all variables structured inside dictionaries
def loadFields(filename):
  """
  Custom function to load the fields from the semiclassical HHG simulations from Simon.  
  """
  data = np.loadtxt(filename, delimiter=',', skiprows=0)
  t = data[:, 0].squeeze()
  Ex = data[:, 1].squeeze()
  Ey = data[:, 2].squeeze()
  Ez = data[:, 3].squeeze()

  fields = {'t': t,
            'Ex': Ex,
            'Ey': Ey,
            'Ez': Ez}

  return fields


#Function taht loads the real-space trajectories into a library for convenience.
# -- This enables me to load many csv files with all variables structured inside dictionaries
def loadRealTrajectories(filename):
  """
  Custom function to load the realspace trajectories from the semiclassical HHG simulations from Simon.  
  """
  data = np.loadtxt(filename, delimiter=',', skiprows=0)
  t = data[:, 0].squeeze()
  x = data[:, 1].squeeze()
  y = data[:, 2].squeeze()
  z = data[:, 3].squeeze()

  trajectories = {'t': t,
                  'x': x,
                  'y': y,
                  'z': z}

  return trajectories


#Function taht loads the real-space trajectories into a library for convenience.
# -- This enables me to load many csv files with all variables structured inside dictionaries
def loadMomentumSpace(filename):
  """
  Custom function to load the momentumspace trajectories from the semiclassical HHG simulations from Simon.  
  """
  data = np.loadtxt(filename, delimiter=',', skiprows=0)
  t = data[:, 0].squeeze()
  kx = data[:, 1].squeeze()
  ky = data[:, 2].squeeze()
  kz = data[:, 3].squeeze()

  trajectories = {'t': t,
                  'kx': kx,
                  'ky': ky,
                  'kz': kz}

  return trajectories

# -- TDDFT Load Functions -- 

def loadTDDFTCurrents(filename):
    """
    Function to load the TDDFT currents generated by a driving field from a linear atomic chain as provided by Simon.
    """
    
    data = np.loadtxt(filename, delimiter=',', skiprows=0)
    t = data[:, 0].squeeze()
    J = data[:, 1].squeeze()
    
    currents = {'t': t,
                'J': J}
    
    return currents

def currentsToFields(w0, t, J):
    """
    Takes the current data from an HHG simulation and:
     - determins frequency spectrum of generated currents
     - converts this to generated field data (spectral and time domain)
     - conveniently calculates intensity and field data in SI units
     - prepares output frequency spectrum, frequency axis, and normalized frequency axis
    
    Inputs
    --------
    w0        Central angular frequency of drive waveform (atomic units)
    F_peak    Peak drive field (atomic units)
    t         Vector of times (atomic units).  Assumed evenly spaced.
    J         Vector of generated currents as a function of time.
    
    Outputs
    ----------
    Outputs a dictionary containing all specific outputs.  Keys listed below.
    
    Output Keys
    -------------
    'w'            Angular frequency axis in atomic units.
    'w_norm'       Normalized frequency axis (harmonic order)
    'J_f'          Current frequency spectrum.
    'F_gen'        Generated fields (derivative of current).
    'F_gen_f'      Frequency spectrum of generated fields.
    """
   
    #Calculate spectrum of current
    J_f = np.fft.fft(J)

    #Define frequency axis for spectrum
    dt = t[1] - t[0]
    N_f = J_f.size
    w = 2*np.pi*np.fft.fftfreq(N_f, d=dt)
    
    #Normalize the frequency axis by harmonic order
    w_norm = w/w0

    #Convert current spectrum to generated field spectrum by taking a derivative in time dJ/dt
    F_gen_f = J_f*1j*w
    
    #Get rid of negative frequency components for this analysis from here on out...
    negativeFreqRegion = np.where(w_norm < 0)[0]
    F_gen_f[negativeFreqRegion] = 0
    
    #Now we can go back to time
    F_gen = np.real(np.fft.ifft(F_gen_f))

    outputs = {'w': w,
               'w_norm': w_norm,
               'J_f': J_f,
               'F_gen': F_gen,
               'F_gen_f': F_gen_f}
                    

    return outputs



def loadTDDFTData(w0, F_peak, folder):
    """
    Function to load all TDDFT data generated by a driving field illuminating a linear atomic chain as provided by Simon.
    
    This function provides all data and relevant information for subseuquent analysis.  This makes it convenient to ensure that
    all analysis in the notebooks is repeatable and applied the same exact way to each dataset.  
    
    A folder is specified, and the following files must be present.
    
    Inputs
    ---------
    w0          central angular frequency of drive field in atomic units
    F_peak      peak driving field in atomic units
    folder      string with folder directory path containing TDDFT data files
    
    
    Files Expected in Folder
    -------------------------
    totalcurrent.dat        contains the generated current data as a function of time (atomic untis)
    obsreal.dat             contains information for reconstructing the driving field and vector potential
    
    
    Outputs
    ---------
    Outptus are all contained in a dictionary that is returned.  See keys below.
    
    Output Keys
    -------------
    'F_peak_SI'    Peak drive field in SI units.
    'I_peak_W_cm2' Peak drive intensity in SI units.
    't'            Time axis for generated currents/fields in atomic units
    'J'            Generated current in atomic units    
    'w'            Angular frequency axis in atomic units.
    'w_norm'       Normalized frequency axis (harmonic order)
    'J_f'          Current frequency spectrum.
    'F_gen'        Generated fields (derivative of current).
    'F_gen_f'      Frequency spectrum of generated fields.
    't_drive'      Time axis for drive fields/vector potential in atomic units
    'A_drive'      Vector potential of driver (normalized)
    'F_drive'      Electric field of driver (normalized)    
    """

    #Calculate the SI peak field and intensity for convenience
    F_peak_SI = F_peak/pca.efieldcon
    I_peak_W_cm2 = F_peak_SI**2*1e-4/(2*pcSI.eta)
       
    #Load the current data
    tddft_currents = loadTDDFTCurrents(folder + '/totalcurrent.dat')
    t = tddft_currents['t']
    J = tddft_currents['J']
    
    #Generate the field data
    output = currentsToFields(w0, t, J)
    
    #Drive field/vector potential construction
    #Note that we normalize both!
    obsreal_data = np.loadtxt(folder + '/obsreal.dat', delimiter=' ', skiprows=0)
    t_drive = obsreal_data[:, 0].squeeze()
    
    A_drive = obsreal_data[:, 8].squeeze()
    A_drive = A_drive/np.max(np.abs(A_drive))
    
    F_drive = -1*np.diff(A_drive)
    F_drive = np.append(F_drive, F_drive[-1])
    F_drive = F_drive/np.max(np.abs(F_drive))
    
    #Now append all other information to the output dictionary
    output['F_peak_SI'] = F_peak_SI
    output['I_peak_W_cm2'] = I_peak_W_cm2
    output['t'] = t
    output['J'] = J
    output['t_drive'] = t_drive
    output['A_drive'] = A_drive
    output['F_drive'] = F_drive
    
    return output
    
def cutSpectralRegion(w, signal_f, w_min, w_max):
    """
    Isolates and filters out a spectral region.  Returns both time and frequency information of this region.
    
    Inputs
    --------
    w                Frequency axis
    signal_f         Signal spectrum
    w_min            Minimum frequency of selection window
    w_max            Maximum frequency of sleection window
    
    Outputs
    ----------
    signal_region    Time-domain information from the selected region.
    signal_region_f  Frequency information from the selected region.
    """


    #Now select out a filtered region
    signal_region_f = np.zeros(signal_f.shape) + 1j*0
    ones_range = np.where((w < w_max)&(w > w_min))[0]
    signal_region_f[ones_range] = tukey(len(ones_range), alpha = 0.1)
    signal_region_f = signal_f*signal_region_f
    
    #Now we can go back to time
    signal_region = np.real(np.fft.ifft(signal_region_f))
    
    return signal_region, signal_region_f